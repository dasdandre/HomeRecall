@page "/backups/{DeviceId:int}"
@using HomeRecall
@using HomeRecall.Services
@using Microsoft.EntityFrameworkCore
@using Microsoft.Extensions.Localization
@inject IStringLocalizer<SharedResource> L
@inject BackupContext Context
@inject NavigationManager NavigationManager
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<MudText Typo="Typo.h4" Class="mb-4">@String.Format(L["Backups_Title"], _device?.Name ?? "Laden...")</MudText>

<div class="d-flex justify-space-between align-center mb-4">
    <MudBreadcrumbs Items="_breadcrumbs" Class="pa-0"></MudBreadcrumbs>
    @if (_selectedItems.Any())
    {
        <MudButton Variant="Variant.Outlined"
                   Color="Color.Error"
                   StartIcon="@Icons.Material.Filled.Delete"
                   OnClick="DeleteSelectedBackups"
                   Class="ml-4">
            @L["Devices_DeleteSelected"] (@_selectedItems.Count)
        </MudButton>
    }
</div>

@if (_device == null)
{
    <MudProgressCircular Color="Color.Default" Indeterminate="true" />
}
else
{
    <MudTable Items="@_device.Backups.OrderByDescending(b => b.CreatedAt)"
              MultiSelection="true"
              @bind-SelectedItems="_selectedItems"
              Hover="true"
              Breakpoint="Breakpoint.Sm"
              Loading="@_loading"
              LoadingProgressColor="Color.Info">
                        <HeaderContent>
            <MudTh>@L["Backups_Date"]</MudTh>
            <MudTh>Firmware</MudTh>
            <MudTh>@L["Backups_Checksum"]</MudTh>
            <MudTh>Info</MudTh>
            <MudTh>@L["Backups_Note"]</MudTh>
            <MudTh>@L["Backups_Locked"]</MudTh>
            <MudTh Style="text-align:right">@L["Devices_Table_Actions"]</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="@L["Backups_Date"]">@context.CreatedAt.ToLocalTime().ToString("g")</MudTd>
            <MudTd DataLabel="Firmware">
                @if (!string.IsNullOrEmpty(context.FirmwareVersion))
                {
                     <MudChip T="string" Size="Size.Small" Variant="Variant.Text" Color="Color.Default">@context.FirmwareVersion</MudChip>
                }
            </MudTd>
            <MudTd DataLabel="@L["Backups_Checksum"]">
                <code style="font-size: 0.8rem">@context.Sha1Checksum.Substring(0, Math.Min(8, context.Sha1Checksum.Length))</code>
            </MudTd>
            <MudTd DataLabel="Info">
                 @if (IsDuplicateOfPrevious(context))
                 {
                     <MudTooltip Text="@L["Backups_ContentUnchanged"]">
                        <MudIcon Icon="@Icons.Material.Filled.ContentCopy" Color="Color.Default" Size="Size.Small" />
                     </MudTooltip>
                 }
                 else
                 {
                     <MudTooltip Text="@L["Backups_ContentChanged"]">
                        <MudIcon Icon="@Icons.Material.Filled.Update" Color="Color.Success" Size="Size.Small" />
                     </MudTooltip>
                 }
            </MudTd>
            <MudTd DataLabel="@L["Backups_Note"]">
                 <MudTextField Value="@context.Note"
                               ValueChanged="@((string s) => UpdateNote(context, s))"
                               Placeholder="@(L["Backups_Note"] + "...")"
                               Margin="Margin.Dense"
                               Variant="Variant.Text"/>
            </MudTd>
            <MudTd DataLabel="@L["Backups_Locked"]">
                <MudToggleIconButton Toggled="@context.IsLocked"
                                     ToggledChanged="@((bool b) => ToggleLock(context))"
                                     Icon="@Icons.Material.Outlined.LockOpen"
                                     Color="@Color.Default"
                                     ToggledIcon="@Icons.Material.Filled.Lock"
                                     ToggledColor="@Color.Warning"
                                     Title="@L["Backups_Locked"]"
                                     ToggledTitle="@L["Backups_Locked"]" />
            </MudTd>
            <MudTd DataLabel="@L["Devices_Table_Actions"]" Style="text-align:right">
                <MudIconButton Icon="@Icons.Material.Filled.Download"
                               Color="Color.Primary"
                               Size="Size.Small"
                               OnClick="@(() => DownloadBackup(context))" />
                <MudIconButton Icon="@Icons.Material.Filled.Delete"
                               Color="Color.Error"
                               Size="Size.Small"
                               OnClick="@(() => DeleteBackup(context))"
                               Disabled="@context.IsLocked" />
            </MudTd>
        </RowTemplate>
    </MudTable>
}

@code {
    [Parameter]
    public int DeviceId { get; set; }


    private Device? _device;
    private bool _loading = true;
    private HashSet<Backup> _selectedItems = new();
    private List<BreadcrumbItem> _breadcrumbs = new List<BreadcrumbItem>();

        protected override async Task OnInitializedAsync()
    {
            await LoadData();

        _breadcrumbs = new List<BreadcrumbItem>
        {
            new BreadcrumbItem(L["Nav_Devices"], href: NavigationManager.ToAbsoluteUri("").ToString()),
            new BreadcrumbItem(L["Common_Backups"], href: null, disabled: true)
        };
    }

    private async Task LoadData()
    {
        _loading = true;
        _device = await Context.Devices
            .Include(d => d.Backups)
            .FirstOrDefaultAsync(d => d.Id == DeviceId);
        _loading = false;
    }

    private bool IsDuplicateOfPrevious(Backup current)
    {
        // Check if the NEXT older backup has the same hash.
        // Since the list is typically ordered descending by date in UI, but we need to check logical predecessor.
        // We can do this in-memory since we load all backups for the device anyway.
        
        var allBackups = _device?.Backups.OrderByDescending(b => b.CreatedAt).ToList();
        if (allBackups == null) return false;

        var index = allBackups.IndexOf(current);
        if (index == -1 || index == allBackups.Count - 1) return false; // Not found or oldest item

        var previous = allBackups[index + 1];
        return previous.Sha1Checksum == current.Sha1Checksum;
    }

    private async Task ToggleLock(Backup backup)
    {
        backup.IsLocked = !backup.IsLocked;
        await Context.SaveChangesAsync();
}

    private async Task UpdateNote(Backup backup, string note)
    {
        backup.Note = note;
        await Context.SaveChangesAsync();
    }

        private async Task DeleteBackup(Backup backup)
    {
        if (backup.IsLocked) return;

        bool? result = await DialogService.ShowMessageBox(
            L["Backups_Delete_Confirm_Title"],
            L["Backups_Delete_Confirm_Message"],
            yesText:L["Common_Delete"], cancelText:L["Common_Cancel"]);

        if (result == true)
        {
            await ExecuteDelete(backup);
            await LoadData();
            Snackbar.Add(L["Backups_Deleted_Success"], Severity.Success);
        }
    }

    private async Task DeleteSelectedBackups()
    {
        var deletableItems = _selectedItems.Where(b => !b.IsLocked).ToList();
        if (!deletableItems.Any())
        {
            Snackbar.Add(L["Backups_DeleteSelected_Warning"], Severity.Warning);
            return;
        }

        bool? result = await DialogService.ShowMessageBox(
            L["Backups_DeleteSelected_Confirm_Title"],
            String.Format(L["Backups_DeleteSelected_Confirm_Message"], deletableItems.Count),
            yesText:L["Common_Delete"], cancelText:L["Common_Cancel"]);

        if (result == true)
        {
            foreach (var backup in deletableItems)
            {
                await ExecuteDelete(backup);
            }
            _selectedItems.Clear();
            await LoadData();
            Snackbar.Add(String.Format(L["Backups_DeletedMultiple_Success"], deletableItems.Count), Severity.Success);
        }
    }

    private async Task ExecuteDelete(Backup backup)
    {
        // Check if file is used by others
        var otherBackupsUsingFile = await Context.Backups
            .AnyAsync(b => b.StoragePath == backup.StoragePath && b.Id != backup.Id);

        if (!otherBackupsUsingFile)
        {
            var backupDirectory = Environment.GetEnvironmentVariable("backup_path") ?? Path.Combine(Directory.GetCurrentDirectory(), "backups");
            var path = Path.Combine(backupDirectory, backup.StoragePath);
            if (File.Exists(path))
            {
                File.Delete(path);
            }
        }

        Context.Backups.Remove(backup);
        await Context.SaveChangesAsync();
    }

    private void DownloadBackup(Backup backup)
    {
        // For MudBlazor, we can redirect to a controller endpoint that serves the file
        // Or inject IJSRuntime to trigger download, but Controller is easier for file serving.
        // We will keep the Controller for file download for now.
        NavigationManager.NavigateTo($"api/DownloadBackup/{backup.Id}", true);
    }
}
